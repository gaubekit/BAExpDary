{{ block title }} Choice Reaction Time (Keyboard) {{ endblock }} {{ block
content }} {% load otree static %}
<link rel="stylesheet" href="{% static 'styles/assessment.css' %}" />

<style>
  /* Center the oTree page title */
  .otree-title,
  .otree-title h1 {
    text-align: center;
  }

  /* Block + text centering */
  .task-container {
    max-width: 760px;
    margin: 0 auto;
    text-align: center;
  }
  .task-description {
    margin: 4px 0 8px;
    color: #333;
  }

  /* Arena sized to comfortably fit D = 280 px and 60 px targets */
  .circle-container {
    position: relative;
    width: 720px;
    height: 560px;
    margin: 8px auto 0;
  }

  .circle-button {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: #000;
    border: 1px solid #333;
    background-color: gray;
    cursor: pointer;
    position: absolute;
    user-select: none;
  }

  /* Center circle fixed at the BOTTOM center of the arena */
  #center-circle {
    position: absolute;
    width: 60px;
    height: 60px;
    background: white;
    border: 1px solid #333;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 12px;
    pointer-events: none; cursor: default;

    /* kill inherited rules to fix shifted center circle */
    transform: none;
    bottom: auto; right: auto;
    top: 0; left: 0; 
  }

  /* Stimulus highlight */
  .circle-button.active {
    background-color: #005000;
  }

  /* NEXT button sits below the task block */
  #next-container {
    display: none;
    text-align: center;
    margin-top: 24px;
  }
</style>

<div class="task-container">
  <p class="task-description">
    Press the number key (1–5) that matches the circle that turns green, as
    quickly as possible.
  </p>

  <div class="circle-container" id="arena">
    <div class="circle-button" id="circle1">1</div>
    <div class="circle-button" id="circle2">2</div>
    <div class="circle-button" id="circle3">3</div>
    <div class="circle-button" id="circle4">4</div>
    <div class="circle-button" id="circle5">5</div>
    <div class="circle-button" id="center-circle"></div>
  </div>
</div>

<!-- NEXT button OUTSIDE the arena -->
<div id="next-container" style="display: none">
  {{ next_button }}
</div>

<script>
  // --- DOM References ---
  const arena = document.getElementById("arena");
  const circleElements = [
    document.getElementById("circle1"),
    document.getElementById("circle2"),
    document.getElementById("circle3"),
    document.getElementById("circle4"),
    document.getElementById("circle5"),
  ];
  const centerCircle = document.getElementById("center-circle");

  // --- Geometry (exact distance) ---
  const W = 60; // px, circle diameter
  const D = 280; // px, REQUIRED center-to-center distance to all targets

  /**
   * Layout: places the center circle at bottom-center and positions
   * circles 1–5 on an arc above it, all exactly D px away from center.
   */
  function layoutCircles() {
    const rect = arena.getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height - W / 2 - 24; // keep a 24px bottom gap

    // Anchor the center circle (CSS does horizontal centering already)
    centerCircle.style.left = centerX - W / 2 + "px";
    centerCircle.style.top = centerY - W / 2 + "px";

    // Slightly tighter arc than before (135°)
    const spread = Math.PI * 0.75; // 135°
    const angleOffset = Math.PI / 2; // 90° straight up
    const startAngle = angleOffset + spread / 2; // leftmost
    const step = -spread / (circleElements.length - 1); // go left→right

    circleElements.forEach((circle, i) => {
      const angle = startAngle + i * step;
      const x = centerX + D * Math.cos(angle) - W / 2;
      const y = centerY - D * Math.sin(angle) - W / 2;
      circle.style.left = x + "px";
      circle.style.top = y + "px";
    });
  }

  // Initial layout + keep it robust on resize
  layoutCircles();
  window.addEventListener("resize", layoutCircles);

  // --- Trial / Task State ---
  let taskActive = true;          // <-- global stop flag (halts scheduling, input, sends)
  let activeIndex = -1;
  let trialIndex = 0;
  let stimulusTime = null;

  // --- Timeout handles (track all so we can cancel on end) ---
  let timeoutId = null;           // random delay to show green (stimulus timer)
  let messageTimeoutId = null;    // clears feedback message

  /**
   * Displays a short feedback message in the center circle.
   * @param {string} text - Message to display
   */
  function showMessage(text) {
    if (!taskActive) return;
    centerCircle.innerText = text;
    clearTimeout(messageTimeoutId);
    messageTimeoutId = setTimeout(() => {
      if (!taskActive) return;
      centerCircle.innerText = "";
    }, 1000); // 1s duration
  }

  /**
   * Returns a random index from 0 to the number of circles - 1.
   * @returns {number}
   */
  function getRandomIndex() {
    return Math.floor(Math.random() * circleElements.length);
  }

  /**
   * Highlights a random circle after a random delay (1–4s).
   * Also records the time the stimulus appeared.
   */
  function highlightRandomCircle() {
    if (!taskActive) return;

    // clear prior highlight
    if (activeIndex !== -1) {
      circleElements[activeIndex].classList.remove("active");
      activeIndex = -1;
    }
    stimulusTime = null;

    // Random delay between 1–4s
    const delay = Math.random() * 3000 + 1000;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      if (!taskActive) return;
      activeIndex = getRandomIndex();
      circleElements[activeIndex].classList.add("active");
      stimulusTime = performance.now();
    }, delay);
  }

  /**
   * Records the user's response data and sends it via liveSend.
   * @param {number} index - The index of the pressed circle
   */
  function recordReaction(index) {
    if (!taskActive || stimulusTime === null || activeIndex === -1) return;
    const responseTime = performance.now() - stimulusTime;

    // Guard to avoid sends after time's up
    if (!taskActive) return;
    liveSend({
      trial_index: trialIndex,
      clicked_index: index,
      is_correct: index === activeIndex,
      reaction_time: responseTime.toFixed(2),
    });
    trialIndex++;
  }

  // --- Event Listeners (Keyboard-Based) ---
  const onKeyDown = (e) => {
    if (!taskActive) return;

    const key = parseInt(e.key, 10);
    if (Number.isNaN(key) || key < 1 || key > 5) return;

    const index = key - 1;

    // Ignore premature responses (no stimulus yet)
    if (stimulusTime === null || activeIndex === -1) return;

    if (index === activeIndex) {
      clearTimeout(timeoutId);
      showMessage("Correct!");
    } else {
      showMessage("Wrong!");
    }

    recordReaction(index);

    // prepare next trial immediately (original behavior preserved)
    highlightRandomCircle();
  };
  document.addEventListener("keydown", onKeyDown);

  // Cleanly stop everything and reveal NEXT
  function endTask() {
    if (!taskActive) return;
    taskActive = false;

    // Clear timers
    [timeoutId, messageTimeoutId].forEach((id) => id && clearTimeout(id));

    // Unhighlight any active circle
    if (activeIndex !== -1) {
      circleElements[activeIndex].classList.remove("active");
      activeIndex = -1;
    }

    // UI tidy-up
    stimulusTime = null;
    centerCircle.innerText = "Time!";

    // Stop further input
    document.removeEventListener("keydown", onKeyDown);

    // Show NEXT
    document.getElementById("next-container").style.display = "block";

    // (Optional) auto-submit page:
    // document.querySelector("form")?.submit();
  }

  // --- Start First Trial ---
  highlightRandomCircle();

  window.addEventListener("load", () => {
    // Time in milliseconds (2 minutes)
    const autoAdvanceMs = 2 * 60 * 1000;
    setTimeout(() => endTask(), autoAdvanceMs);
  });
</script>


{{ formfields }} {{ endblock }}
