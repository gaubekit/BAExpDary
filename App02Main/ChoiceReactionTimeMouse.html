{{ block title }} Choice Reaction Time (Mouse) {{ endblock }}
{{ block content }}
{% load otree static %}
<link rel="stylesheet" href="{% static 'styles/assessment.css' %}" />

<style>
  /* Center the oTree page title */
  .otree-title, .otree-title h1 { text-align: center; }

  /* Block + text centering */
  .task-container { max-width: 760px; margin: 0 auto; text-align: center; }
  .task-description { margin: 4px 0 8px; color: #333; }

  /* Arena sized to fit D=280 and 60px targets comfortably */
  .circle-container {
    position: relative;
    width: 720px;
    height: 560px;
    margin: 8px auto 0;
  }

  .circle-button {
    width: 60px; height: 60px; border-radius: 50%;
    display: flex; justify-content: center; align-items: center;
    font-size: 24px; font-weight: bold; color: #000;
    border: 1px solid #333; background-color: gray;
    cursor: pointer; position: absolute; user-select: none;
  }

  /* Bottom-center circle: JS sets exact top/left (no transforms/bottom here) */
  #center-circle {
    position: absolute;
    width: 60px; height: 60px; border-radius: 50%;
    background-color: white; border: 1px solid #333;
    display: flex; justify-content: center; align-items: center;
    font-size: 12px; pointer-events: auto; cursor: pointer;
    transform: none !important; bottom: auto !important; right: auto !important;
    top: 0; left: 0; /* JS will place precisely */
  }

  /* Green highlight for active target */
  .circle-button.active { background-color: #005000; }

  /* NEXT button centered below the task block, with breathing room */
  :root { --next-gap: 72px; }
  #next-container { display: none; text-align: center; margin-top: var(--next-gap); }
</style>

<div class="task-container">
  <p class="task-description">
    Hold the bottom circle to arm a trial. When one of the five circles turns green,
    release and click it as fast as you can.
  </p>

  <div class="circle-container" id="arena">
    <div class="circle-button" id="circle1"></div>
    <div class="circle-button" id="circle2"></div>
    <div class="circle-button" id="circle3"></div>
    <div class="circle-button" id="circle4"></div>
    <div class="circle-button" id="circle5"></div>
    <div class="circle-button" id="center-circle"></div>
  </div>
</div>

<!-- NEXT button OUTSIDE the arena -->
<div id="next-container" style="display: none">
  {{ next_button }}
</div>

<script>
  // --- DOM References ---
  const arena = document.getElementById("arena");
  const circleElements = [
    document.getElementById("circle1"),
    document.getElementById("circle2"),
    document.getElementById("circle3"),
    document.getElementById("circle4"),
    document.getElementById("circle5"),
  ];
  const centerCircle = document.getElementById("center-circle");

  // --- Geometry (exact distance) ---
  const W = 60;          // px, circle diameter
  const D = 280;         // px, REQUIRED center-to-center distance to all targets
  const BOTTOM_GAP = 24; // px, visual gap from arena bottom to center circle

  /**
   * Layout: places the center circle at bottom-center and positions
   * circles 1–5 on a 135° arc above it, all exactly D px away.
   * Order is left→right.
   */
  function layoutCircles() {
    const rect = arena.getBoundingClientRect();
    const centerX = rect.width / 2;
    const centerY = rect.height - (W / 2) - BOTTOM_GAP; // bottom-center

    // Place the bottom center precisely (no CSS transforms involved)
    centerCircle.style.left = (centerX - W / 2) + "px";
    centerCircle.style.top  = (centerY - W / 2) + "px";

    // 135° arc, centered at 90° (straight up)
    const spread = Math.PI * 0.75;      // 135°
    const angleOffset = Math.PI / 2;    // 90°
    const startAngle = angleOffset + spread / 2;         // leftmost
    const step = -spread / (circleElements.length - 1);  // left → right

    circleElements.forEach((el, i) => {
      const angle = startAngle + i * step;
      const x = centerX + D * Math.cos(angle) - W / 2;
      const y = centerY - D * Math.sin(angle) - W / 2;
      el.style.left = x + "px";
      el.style.top  = y + "px";
    });
  }

  // Initial layout + keep it robust on resize
  layoutCircles();
  window.addEventListener("resize", layoutCircles);

  // --- State Variables ---
  let activeIndex = -1;
  let holding = false;
  let canClick = false;           // becomes true once a target turns green
  let holdTimeout = null;
  let trialIndex = 0;

  let stimOnsetAt = 0;            // when a circle turned green
  let releaseAt = null;           // when center was released (start of movement)
  let lastClick = 0;              // time of release (used to calc movement time)

  // --- Small helpers ---
  function showMessage(text) {
    centerCircle.innerText = text;
    setTimeout(() => { centerCircle.innerText = ""; }, 1000);
  }

  function getRandomIndex() {
    return Math.floor(Math.random() * circleElements.length);
  }

  function resetCircles() {
    circleElements.forEach((circle) => {
      circle.classList.remove("active");
      circle.style.backgroundColor = "gray";
    });
    activeIndex = -1;
    canClick = false;
  }

  function resetTrial() {
    resetCircles();
    centerCircle.style.backgroundColor = "white";
    centerCircle.style.border = "1px solid #333";
    centerCircle.classList.remove("holding");
    holding = false;
    canClick = false;
    stimOnsetAt = 0;
    releaseAt = null;
  }

  function send(payload) {
    // round numeric times to 2 decimals if present
    ["reaction_time", "movement_time"].forEach(k => {
      if (payload[k] != null) payload[k] = Number(payload[k].toFixed(2));
    });
    payload.trial_index = trialIndex;
    liveSend(payload);
  }

  function highlightRandomCircle() {
    resetCircles();
    activeIndex = getRandomIndex();
    const target = circleElements[activeIndex];
    target.classList.add("active");
    target.style.backgroundColor = "#005000"; // green
    canClick = true;
    stimOnsetAt = performance.now();
  }

  // --- Event Listeners (responses & flow) ---

  // Enable pointer on center
  centerCircle.style.pointerEvents = "auto";
  centerCircle.style.cursor = "pointer";

  // Press & hold to arm the trial
  centerCircle.addEventListener("mousedown", () => {
    if (holding || canClick) return;
    holding = true;
    centerCircle.style.backgroundColor = "gray";
    centerCircle.classList.add("holding");

    const delay = Math.random() * 3000 + 1000; // 1–4s
    holdTimeout = setTimeout(() => {
      if (holding) highlightRandomCircle();
    }, delay);
  });

  // Release center:
  // - If target not shown yet -> too early (log incorrect, advance trial)
  // - If target shown -> record reaction_time (release), wait for click
  centerCircle.addEventListener("mouseup", () => {
    if (!holding) return;
    holding = false;
    clearTimeout(holdTimeout);
    centerCircle.style.backgroundColor = "white";
    centerCircle.style.border = "1px solid #333";

    if (!canClick) {
      // Too early: no stimulus yet
      showMessage("Too early!");
      send({ is_correct: false });
      trialIndex++;               // finalize this (failed) trial
      resetTrial();
      return;
    }

    // Valid release after stimulus
    releaseAt = performance.now();
    lastClick = releaseAt;
    const rtLeave = releaseAt - stimOnsetAt;
    // Map to server key expected by your live_method
    send({ reaction_time: rtLeave });
    // Don't increment trialIndex yet; we finalize on the target click
  });

  // Cancel trial if cursor leaves center while holding
  centerCircle.addEventListener("mouseleave", () => {
    if (!holding) return;
    holding = false;
    clearTimeout(holdTimeout);
    centerCircle.style.backgroundColor = "white";
    centerCircle.style.border = "1px solid #333";
    centerCircle.classList.remove("holding");
    showMessage("Release your mouse");
    // Treat as early cancel: log as incorrect and advance
    send({ is_correct: false });
    trialIndex++;
    resetTrial();
  });

  // Click on one of the five targets
  circleElements.forEach((circle, index) => {
    circle.addEventListener("click", () => {
      if (!canClick) {
        showMessage("Not yet!");
        return;
      }

      // If they haven't released the center yet, force an incorrect outcome
      if (releaseAt == null) {
        showMessage("Release first!");
        send({ is_correct: false, clicked_index: index });
        trialIndex++;
        resetTrial();
        return;
      }

      const correct = index === activeIndex;
      const mt = performance.now() - lastClick; // movement time since release

      showMessage(correct ? "Correct!" : "Wrong!");

      // Finalize trial (send movement_time, correctness, clicked index)
      send({
        movement_time: mt,
        is_correct: correct,
        clicked_index: index
      });
      trialIndex++;

      setTimeout(resetTrial, 500);
    });
  });

  window.addEventListener("load", () => {
    // Time in milliseconds (2 minutes)
    const autoAdvanceMs = 2 * 60 * 1000;
    setTimeout(() => {
      document.getElementById("next-container").style.display = "block";
    }, autoAdvanceMs);
  });
</script>

{{ formfields }} {{ endblock }}
